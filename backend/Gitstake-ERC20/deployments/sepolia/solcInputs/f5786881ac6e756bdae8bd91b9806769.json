{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/GitHubStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.2 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract GitHubStaking {\n    struct Stake {\n        address staker;\n        uint amt;\n        uint pullReqId;\n    }\n    struct Issue {\n        address creator;\n        uint prize;\n        bool solved;\n        address solver;\n        uint stakeCount;\n        uint totalStakeAmt;\n        mapping(uint => Stake) stakes; // index -> konsa address, kitna stakeAmt\n    }\n\n    struct Repo {\n        mapping(uint => Issue) issues;\n        uint issueCount;\n    }\n    struct WalletStats {\n        uint lostStakeCount;\n        uint wonStakeCount;\n        uint totalAmtStaked;\n        uint openAmtStaked;\n        uint totalStakes;\n        uint openStakes;\n        uint rewardsEarned;\n        uint withdraw_proceedings;\n        uint lost_refund;\n    }\n\n    struct IssueStats {\n        uint totalPriceAmt_SetByMe;\n        uint openPriceAmt_SetByMe;\n        uint totalIssues_SetByMe;\n        uint openIssues_SetByMe;\n    }\n\n    struct Wallet {\n        string gitUsername;\n        WalletStats stats;\n        IssueStats issueStats;\n    }\n\n    mapping(uint => Repo) public repos; // RepoId -> Repo\n    mapping(address => Wallet) public wallets;\n\n    uint256 private constant MIN_PRIZE = 5;\n    uint private constant DEDUCTION_FACTOR = 10;\n    uint256 private constant MIN_STAKE = 10;\n    uint private soldTokens = 0;\n\n    IERC20 public s_token;\n    address public immutable i_owner;\n\n    // events\n    event IssueCreated(\n        uint256 indexed repoId,\n        uint256 indexed issueId,\n        address indexed creator,\n        uint256 prize\n    );\n\n    event IssueSolved(\n        uint256 indexed repoId,\n        uint256 indexed issueId,\n        uint256 pullReqId,\n        address creator,\n        address indexed solver,\n        uint256 prize\n    );\n\n    event StakePlaced(\n        uint256 indexed repoId,\n        uint256 indexed issueId,\n        uint256 pullReqId,\n        address indexed staker,\n        uint256 amt\n    );\n\n    constructor(address token) {\n        s_token = IERC20(token);\n        i_owner = msg.sender;\n    }\n\n    function addUserToWallet(address wallet, string memory username) public {\n        wallets[wallet].gitUsername = username;\n    }\n\n    function requestTokens(address to, uint amt) public {\n        bool success = s_token.transfer(to, amt);\n        require(success);\n        soldTokens = soldTokens + amt;\n    }\n\n    function fundContract() public payable {\n        require(msg.sender == i_owner);\n        bool success = s_token.transferFrom(\n            msg.sender,\n            address(this),\n            msg.value\n        );\n        require(success);\n    }\n\n    // Create a new issue with a prize\n    function createIssue(\n        uint repoId,\n        uint issueId,\n        uint256 prize\n    ) public payable {\n        // require(\n        //     wallets[msg.sender].gitUsername != \"\",\n        //     \"Wallet not found in contract.\"\n        // );\n\n        Repo storage repo = repos[repoId];\n        Issue storage issue = repo.issues[issueId];\n        require(issue.creator == address(0), \"Issue already exists\");\n        require(prize >= MIN_PRIZE, \"Prize amount must be greater than 5\");\n\n        bool success = s_token.transferFrom(msg.sender, address(this), prize);\n        if (success) {\n            issue.creator = msg.sender;\n            issue.prize = prize;\n            issue.solved = false;\n            issue.solver = address(0);\n            issue.stakeCount = 0;\n            issue.totalStakeAmt = 0;\n            repo.issueCount++;\n\n            wallets[msg.sender].issueStats.totalIssues_SetByMe++;\n            wallets[msg.sender].issueStats.openIssues_SetByMe++;\n\n            wallets[msg.sender].issueStats.totalPriceAmt_SetByMe =\n                wallets[msg.sender].issueStats.totalPriceAmt_SetByMe +\n                prize;\n            wallets[msg.sender].issueStats.openPriceAmt_SetByMe =\n                wallets[msg.sender].issueStats.openPriceAmt_SetByMe +\n                prize;\n\n            emit IssueCreated(repoId, issueId, msg.sender, prize);\n        }\n    }\n\n    // Stake an amount on an issue\n    function stakeOnIssue(\n        uint repoId,\n        uint issueId,\n        uint pullReqId,\n        uint256 amt\n    ) public payable {\n        require(amt >= MIN_STAKE, \"Min Stake Amount is 0.01 GST.\");\n        Issue storage issue = repos[repoId].issues[issueId];\n        require(issue.creator != msg.sender, \"Issue creator cannot stake.\");\n        require(issue.creator != address(0), \"Issue does not exist\"); //address(0) represents the zero address in Solidity.\n        require(issue.creator != msg.sender, \"Issue creator cannot stake\");\n        require(!issue.solved, \"Issue already solved\");\n        bool success = s_token.transferFrom(msg.sender, address(this), amt);\n        if (success) {\n            issue.stakeCount++;\n            issue.stakes[issue.stakeCount].pullReqId = pullReqId;\n            issue.stakes[issue.stakeCount].staker = msg.sender;\n            issue.stakes[issue.stakeCount].amt = amt;\n            issue.totalStakeAmt += amt;\n\n            wallets[msg.sender].stats.totalAmtStaked += amt;\n            wallets[msg.sender].stats.openAmtStaked += amt;\n\n            wallets[msg.sender].stats.totalStakes++;\n            wallets[msg.sender].stats.openStakes++;\n\n            emit StakePlaced(repoId, issueId, pullReqId, msg.sender, amt);\n        }\n    }\n\n    function closeIssueNoSolver(uint repoId, uint issueId) public {\n        Issue storage issue = repos[repoId].issues[issueId];\n        require(issue.creator != address(0), \"Issue does not exist\");\n        issue.solved = true;\n        bool success = s_token.transferFrom(\n            address(this),\n            issue.creator,\n            issue.prize\n        );\n        require(success);\n    }\n\n    //  Mark an issue as solved and distribute rewards\n    function markSolved(\n        uint repoId,\n        uint issueId,\n        uint pullReqId,\n        address solver\n    ) public {\n        require(msg.sender != solver, \"Cannot declare yourself winner.\");\n        Issue storage issue = repos[repoId].issues[issueId];\n        require(!issue.solved, \"Issue already solved\");\n        require(\n            msg.sender == issue.creator,\n            \"Only issue creator can mark as solved\"\n        );\n        updateWalletForSolvedIssue(solver, issue.prize);\n\n        issue.solved = true;\n        issue.solver = solver;\n\n        rejectOthers(repoId, issueId, pullReqId, solver);\n\n        emit IssueSolved(\n            repoId,\n            issueId,\n            pullReqId,\n            msg.sender,\n            solver,\n            issue.prize\n        );\n    }\n\n    function updateWalletForSolvedIssue(address solver, uint prize) internal {\n        wallets[solver].stats.wonStakeCount++;\n        wallets[solver].stats.rewardsEarned += prize;\n        wallets[solver].stats.withdraw_proceedings += prize;\n    }\n\n    function rejectOthers(\n        uint repoId,\n        uint issueId,\n        uint pullReqId,\n        address solver\n    ) public {\n        Issue storage issue = repos[repoId].issues[issueId];\n        // Deduct from other stakers and refund the remaining amount\n        for (uint i = 0; i < issue.stakeCount; i++) {\n            address staker = issue.stakes[i].staker;\n            wallets[staker].stats.openAmtStaked =\n                wallets[staker].stats.openAmtStaked -\n                issue.stakes[i].amt;\n            if (staker == solver && issue.stakes[i].pullReqId == pullReqId) {\n                wallets[solver].stats.withdraw_proceedings += issue\n                    .stakes[i]\n                    .amt;\n                continue;\n            }\n\n            uint deduction = ((issue.stakes[i].amt / issue.stakeCount) *\n                DEDUCTION_FACTOR);\n            uint refund = issue.stakes[i].amt - deduction;\n            wallets[staker].stats.lostStakeCount++;\n            wallets[staker].stats.lost_refund += refund;\n            wallets[staker].stats.withdraw_proceedings -= refund;\n        }\n    }\n\n    // Withdraw refund balance\n    function withdraw_reward() public payable {\n        uint amount = wallets[msg.sender].stats.withdraw_proceedings;\n        require(amount > 0, \"Nothing to withdraw.\");\n        wallets[msg.sender].stats.withdraw_proceedings = 0;\n        bool success = s_token.transferFrom(address(this), msg.sender, amount);\n        require(success, \"Transfer failed.\");\n    }\n\n    function getBasicWalletDetails()\n        public\n        view\n        returns (\n            string memory gitUsername,\n            uint lostStakeCount,\n            uint wonStakeCount\n        )\n    {\n        Wallet storage wallet = wallets[msg.sender];\n        return (\n            wallet.gitUsername,\n            wallet.stats.lostStakeCount,\n            wallet.stats.wonStakeCount\n        );\n    }\n\n    function getStakingWalletDetails()\n        public\n        view\n        returns (\n            uint totalAmtStaked,\n            uint openAmtStaked,\n            uint totalStakes,\n            uint openStakes\n        )\n    {\n        Wallet storage wallet = wallets[msg.sender];\n        return (\n            wallet.stats.totalAmtStaked,\n            wallet.stats.openAmtStaked,\n            wallet.stats.totalStakes,\n            wallet.stats.openStakes\n        );\n    }\n\n    function getRewardsWalletDetails()\n        public\n        view\n        returns (\n            uint rewardsEarned,\n            uint withdraw_proceedings,\n            uint lost_refund\n        )\n    {\n        Wallet storage wallet = wallets[msg.sender];\n        return (\n            wallet.stats.rewardsEarned,\n            wallet.stats.withdraw_proceedings,\n            wallet.stats.lost_refund\n        );\n    }\n\n    function getIssueStats()\n        public\n        view\n        returns (\n            uint totalPriceAmt_SetByMe,\n            uint openPriceAmt_SetByMe,\n            uint totalIssues_SetByMe,\n            uint openIssues_SetByMe\n        )\n    {\n        Wallet storage wallet = wallets[msg.sender];\n        return (\n            wallet.issueStats.totalPriceAmt_SetByMe,\n            wallet.issueStats.openPriceAmt_SetByMe,\n            wallet.issueStats.totalIssues_SetByMe,\n            wallet.issueStats.openIssues_SetByMe\n        );\n    }\n\n    function getTotalStakeAmount(\n        uint repoId,\n        uint issueId\n    ) public view returns (uint256) {\n        Issue storage issue = repos[repoId].issues[issueId];\n        return issue.totalStakeAmt;\n    }\n\n    function getTotalStakers(\n        uint repoId,\n        uint issueId\n    ) public view returns (uint256) {\n        Issue storage issue = repos[repoId].issues[issueId];\n        return issue.stakeCount;\n    }\n\n    function getIssue(\n        uint repoId,\n        uint issueId\n    )\n        public\n        view\n        returns (\n            address creator,\n            uint prize,\n            bool solved,\n            address solver,\n            uint stakeCount,\n            uint totalStakeAmt\n        )\n    {\n        Issue storage issue = repos[repoId].issues[issueId];\n        require(issue.creator != address(0), \"Issue does not exist\");\n        return (\n            issue.creator,\n            issue.prize,\n            issue.solved,\n            issue.solver,\n            issue.stakeCount,\n            issue.totalStakeAmt\n        );\n    }\n\n    function getStakeCount(\n        uint repoId,\n        uint issueId\n    ) public view returns (uint) {\n        return repos[repoId].issues[issueId].stakeCount;\n    }\n\n    function getStake(\n        uint repoId,\n        uint issueId,\n        uint index\n    ) public view returns (address staker, uint amt) {\n        Issue storage issue = repos[repoId].issues[issueId];\n        Stake storage stake = issue.stakes[index];\n        require(issue.creator != address(0), \"Issue does not exist\");\n        return (stake.staker, stake.amt);\n    }\n\n    function getEstDeductionRateOnIssue(\n        uint repoId,\n        uint issueId,\n        uint approx_amt\n    ) public view returns (uint) {\n        Issue storage issue = repos[repoId].issues[issueId];\n        uint deduction = ((approx_amt / issue.stakeCount) * DEDUCTION_FACTOR);\n        return deduction;\n    }\n\n    function getDeductionFactor() public pure returns (uint) {\n        return DEDUCTION_FACTOR;\n    }\n\n    function getSoldTokens() public view returns (uint) {\n        return soldTokens;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}